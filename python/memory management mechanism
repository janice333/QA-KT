refer to: https://blog.csdn.net/zx870121209/article/details/81363311
          https://www.cnblogs.com/yhll/p/8908882.html
          
一句话概括：引用计数为主，清除标记，分代回收为辅

python的存储问题：
1、python中的对象：
由于python中万物皆对象，所以python的存储问题是对象的存储问题，并且对于每个对象，python会分配一块内存空间去存储它

2、对象的内存使用：
对于整数和短小的字符等，python会执行缓存机制，即将这些对象进行缓存，不会为相同的对象分配多个内存空间
具体解释：
为了探索对象在内存的存储，我们可以求助于Python的内置函数id()。它用于返回对象的身份(identity)。其实，这里所谓的身份，就是该对象的内存地址。
1.a = 1
2.print(id(a))
3.print(hex(id(a)))
该代码返回的是：内存地址的十进制和十六进制表示

在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。当我们创建多个等于1的引用时，实际上是让所有这些引用指向同一个对象。  
1.a = 1
2.b = 1
3.print(id(a))
4.print(id(b))
上面程序返回
11246696
11246696
可见a和b实际上是指向同一个对象的两个引用。

为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指的对象是否相同。
# True
a = 1
b = 1
print(a is b)

# True
a = "good"
b = "good"
print(a is b)
 
# True  注：原博这里写的是False，但是在python3的运行环境下输出的是True
a = "very good morning"
b = "very good morning"
print(a is b)
 
# False
a = []
b = []
print(a is b)
可以看到，由于Python缓存了整数和短字符串，因此每个对象只存有一份。比如，所有整数1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身。（长的字符串和）其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。

3、对象引用对象：
容器对象，如列表、元组、字典等，存储的其他对象，仅仅是其他对象的引用，即地址，并不是这些对象本身


引用计数器：
1、一个对象会记录着引用自己的对象的个数，每增加一个引用，个数加一，每减少一个引用，个数减一
2、查看引用对象个数的方法：导入sys模块，使用模块中的gettrefcount(对象)方法，由于这里也是一个引用，故输出的结果多1
3、增加引用个数的情况
  （1）对象被创建p = Person()，增加1；
  （2）对象被引用p1 = p，增加1；
  （3）对象被当作参数传入函数func(object)，增加2，原因是函数中有两个属性在引用该对象；
  （4）对象存储到容器对象中l = [p]，增加1
4、减少引用个数的情况：
  （1）对象的别名被销毁del p，减少1；
  （2）对象的别名被赋予其他对象，减少1；
  （3）对象离开自己的作用域，如getrefcount(对象)方法，每次用完后，其对对象的那个引用就会被销毁，减少1；
  （4）对象从容器对象中删除，或者容器对象被销毁，减少1
5、引用计数器用法：
import sys
class Person(object):
    pass
p = Person()
p1 = p
print(sys.getrefcount(p))
p2 = p1
print(sys.getrefcount(p))
p3 = p2
print(sys.getrefcount(p))
del p1
print(sys.getrefcount(p))
多一个引用，结果加1，销毁一个引用，结果减1
6、引用计数器机制：利用引用计数器方法，在检测到对象引用个数为0时，对普通的对象进行释放内存的机制


循环引用（引用环）：
1、循环引用即对象之间进行相互引用，出现循环引用后，利用上述引用计数机制无法对循环引用中的对象进行释放空间，这就是循环引用问题
2、循环引用形式：
class Person(object):
    pass
class Dog(object):
    pass
p = Person()
d = Dog()
p.pet = d
d.master = p
即对象p中的属性引用d，而对象d中属性同时来引用p，从而造成仅仅删除p和d对象，也无法释放其内存空间，因为他们依然在被引用。深入解释就是，循环引用后，p和d被引用个数为2，删除p和d对象后，两者被引用个数变为1，并不是0，而python只有在检查到一个对象的被引用个数为0时，才会自动释放其内存，所以这里无法释放p和d的内存空间


垃圾回收（底层层面——原理）
1、垃圾回收的作用：从经过引用计数器机制后还没有被释放掉内存的对象中，找到循环引用对象，并释放掉其内存
2、垃圾回收检测流程：
 （1）找到循环引用并释放内存：
   * 收集所有容器对象（循环引用只针对容器对象，其他对象不会产生循环引用），使用双向链表（可以看作一个集合）对这些对象进行引用
   * 针对每一个容器对象，使用变量gc_refs来记录当前对应的应用个数
   * 对于每个容器对象，找到其正在引用的其他容器对象，并将这个被引用的容器对象引用计数减去1
   * 经过上一个步骤之后，检查所有的容器对象的引用计数，若为0，则证明该容器对象是由于循环引用活下来的，并对其进行销毁
 （2）如何提升查找循环引用过程的性能：
   由（1）可知，循环引用查找和销毁过程非常繁琐，要分别处理每一个容器对象，所以python考虑了一种改善性能的做法，即分代回收。首先是一个假设，即如果一个对象被检测了10次还没有被销毁，就减少对其的检测频率；基于这个假设提出一套机制，即分代回收机制。


分代回收:
Python同时采用了分代(generation)回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。
Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。
这两个次数即get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。
同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。
import gc
gc.set_threshold(700, 10, 5)

分代回收总结：
1、机制：
  （1）默认一个对象被创建出来后，属于0代
  （2）如果经历过这一代“垃圾回收”后，依然存活，则划分到下一代
  （3）“垃圾回收”的周期顺序为：
      * 0代“垃圾回收”一定次数，会触发0代和1代回收
      * 1代“垃圾回收”一定次数，会触发0代、1代和2代回收
2、查看和设置相关参数：
gc模块的get_threshold()方法：
import gc
print(gc.get_threshold())
gc.set_threshold(700,10,5)
通过这个机制，循环引用处理过程就会得到很大的性能提升


垃圾回收时机（应用层面——重点）
1、自动回收：
触发条件：
（1）开启垃圾回收机制：gc.enable()：开启垃圾回收机制（默认开始）
                      gc.disable()：关闭垃圾回收机制
                      gc.isenabled()：判定是否开启
（2）并且达到了垃圾回收的阈值：
     垃圾回收器中，新增的对象个数和释放的对象个数之差到达某个阈值
     涉及的方法：* gc.get_threshold()：获取自动回收阈值
                 * gc.set_threshold()：设置自动回收阈值
2、手动回收：
这里要使用gc模块中的collect()方法，使得执行这个方法时执行分代回收机制
import objgraph
import gc
import sys
class Person(object):
    pass
class Dog(object):
    pass
p = Person()
d = Dog()
p.pet = d
d.master = p
del p
del d
gc.collect()
print(objgraph.count("Person"))
print(objgraph.count("Dog"))

其中objgraph模块的count()方法是记录当前类产生的实例对象的个数


内存池：
  Python引用了一个内存池(memory pool)机制，即Pymalloc机制(malloc:n.分配内存)，用于对小块内存的申请和释放管理
1、内存池的概念：
  当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，致使效率降低。内存池的概念就是预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。
2、Python中的内存管理机制——Pymalloc：
　 python中的内存管理机制都有两套实现：
  （1）一套是针对小对象，就是大小小于256kb时，pymalloc会在内存池中申请内存空间；
  （2）当大于256kb，则会直接执行 new/malloc 的行为来申请新的内存空间。
3、Python的内存机制呈现金字塔形状：refer to： https://www.jianshu.com/p/1ceff319141c
（1）-1，-2层主要有操作系统进行操作；
（2）第0层是C中的malloc，free等内存分配和释放函数进行操作；
（3）第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存；
（4）第3层是最上层，也就是我们对Python对象的直接操作；
4、内存释放
关于释放内存方面，当一个对象的引用计数变为 0 时，python就会调用它的析构函数。调用析构函数并不意味着最终一定会调用free 释放内存空间，如果真是这样的话，那频繁地申请、释放内存空间会使 Python的执行效率大打折扣。因此在析构时也采用了内存池机制，从内存池申请到的内存会被归还到内存池中，以避免频繁地释放动作。
